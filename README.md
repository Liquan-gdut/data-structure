数据结构与算法丨基础知识小结
-------------------------
>> 各种数据结构的物理本质、逻辑与存储结构、模型<br>
树和二叉树的遍历、最优二叉树、图的最小生成树<br>
查找算法<br>
排序算法<br>

## 一、数据结构
>> 摘要：线性表、栈和队列、串：物理本质，逻辑、存储结构，对应模型，应用案例<br>树和二叉树、图：逻辑与存储结构，遍历方法，最优二叉树算法、最小生成树算法<br>
### 1、线性表<br>
（1）本质定义：一系列逻辑上相邻的有限序列。<br>
（2）逻辑结构：线性结构，除第一个外，所有元素只有一个前驱，除最后一个外，所有元素只有一个后继<br>
（3）存储结构：<br>
     ①顺序存储：在物理内存上也是一序列相邻的空间。<br>
     ②链式存储：在物理内存中不一定相邻。单链表，每个结点包含数据和一个指向后继的指针；双链表，每个结点包含数据和两个指针，一个指向前驱一个指向后继；<br>
### 2、栈和队列<br>
（1）本质定义：<br>
       栈：被限制的线性表，只能“后进先出”。经典模型：饼干桶模型<br>
      队列：被限制的线性表，只能“先进先出”，从头部输出，从尾部输入。经典模型：排队打饭模型<br>
### 3、串<br>
（1）本质定义：就是字符串了。<br>
（2）存储结构<br>
       ①顺序存储<br>
       ②堆分配存储：可根据“串长”动态分配数组长度。<br>
       ③链式存储：数据域+指针域<br>
（3）子串匹配算法<br>
       ①普通算法：循环匹配→回退→匹配→循环次数=原串-子串<br>
       ②模式匹配(KMP)算法：<br>
          适合“子串”与“父串”存在大量相似元素的情况（略）<br>
### 4、树和二叉树<br>
（1）本质定义：一种非线性结构，递归的概念：每个节点可以分成若干不相交节点，每个节点（除根节点外）只有一个父节点。<br>
（2）经典模型：家族谱，层次结构。<br>
（3）二叉树的存储结构：<br>
        ①顺序：每个结点打上完全二叉树的标号，存到数组对应位置中；<br>
        ②(常用)链式：左孩子指针+数据+右孩子指针<br>
（4）树的存储结构：①父亲表示法：数据+父节点指针；②孩子表示法：数据+每个孩子<br>
（5）二叉树的遍历<br>
基本原则：先左后右，递归<br>
①先根遍历：根左右<br>
②中根遍历：左根右<br>
③后根遍历：左右根<br>
（6）最优二叉树（赫夫曼树）<br>
     ①经典模型：成绩评定<br>
     ②本质定义：每个叶子结点都“带权”（权就是代价），到每个节点的带权总和最小的二叉树，称为最优二叉树<br>
     ③算法：<br>
a.将所有带权节点放入同一个集合当中<br>
b.集合中取出(并删除)两棵根节点最小的二叉树，作为左右子树，根节点和为新的根节点，<br>
c.生成的二叉树再加入到集合当中<br>
d.重复上面两步骤<br>
（7）赫夫曼编码：遵循“左‘0’，右‘1’”原则<br>
### 5、图<br>
（1）本质定义：多对多的非线性结构<br>
（2）图的遍历<br>
     ①深度优先<br>
        执行机制：类似于“先根遍历”，以某节点为出发点→先根遍历→遇到重复就回退→所有节点访问完则截止<br>
     ②广度优先<br>
        执行机制：按层次遍历，先上后下，亲兄弟同时访问，堂兄弟先左后右。<br>
（3）最小生成树算法<br>
    经典模型：城市交通网<br>
    算法：<br>
①建集合U，并入一个起始节点<br>
②找出到集合U的最小代价边，并入新节点到U<br>
③重复步骤2<br>
## 二、经典算法<br>
> 摘要：算法衡量指标：①存储效率，执行效率，即空间效率，时间效率<br>
### 1、查找算法<br>
（1）顺序查找：针对排好序的序列<br>
    ①普通的全表遍历查找<br>
    ②二分法查找<br>
    ③插值查找：改进的二分法，自适应二分法<br>
       算法过程：mid=[（目标值 - 序列最小值）/（序列最大值 - 序列最小值）] x序列长度<br>
    ④斐波那契查找：黄金分割系数<br>
    ⑤分块查找：块内无序，块间有序<br>
（2）树查找<br>
    ⑥二叉排序树<br>
       算法过程：<br>
二叉搜索树：左子树小于根节点，右子树大于根节点<br>
二叉搜索树构造过程：现将序列排序，中点递归<br>
插入过程：先序遍历进行比较<br>
    ⑦平衡2-3排序树<br>
        本质：二叉排序树的改进，有二叉树，也有三叉树。<br>
    ⑧红黑树<br>
       本质：2-3排序树的改进，能转化的全部转化为三叉树<br>
    ⑨B/B+树（待完善）<br>
（3）哈希查找：牺牲存储效率，换取查找效率<br>
    ①将序列进行哈希存储，确定“定址”、“冲突”方案<br>
    ②算法：目标值输入到哈希函数，与对应地址的值进行比较→若位置为空，则结果为空，相等则输出位置，不等则进行“冲突处理”(如线性探测)→若位置为空，则结果为空，相等则输出位置，不等则进行“再冲突处理”(如二次线性探测)→相等则输出，不等则输出结果。<br>
### 2、排序算法<br>
（1）非线性比较类<br>
（2）线性非比较类<br>
![image](https://github.com/Liquan-gdut/data-structure/blob/master/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png)<br>
## 整体总结：<br>
1、线性表、二叉树的逻辑与存储结构<br>
2、二叉树的遍历算法<br>
3、查找、排序算法（平时多练习，采用js、Python、C++等语言实现）<br>
